#define GLOW_MULTIPLIER     4.0f

// Pixel size will be considered 1/1000th of the screen, just to make the effect similar on every resolution
#define PIXEL_SIZE_BASE     0.0010f
#define PIXEL_SIZE_BASE_2   0.0020f
#define PIXEL_SIZE_BASE_3   0.0030f
#define PIXEL_SIZE_BASE_4   0.0040f
#define PIXEL_SIZE_BASE_5   0.0050f

// Constants to multiply light value
#define C1   0.05f
#define C2   0.07f
#define C3   0.10f
#define C4   0.15f
#define C5   0.20f
#define C6   0.25f

// Tone mapping function
float4 Tonemap( float4 x )
{
// Tone mapping function using linear strength (A) and toe strength (B)
  // Colour = ( A * x^2 ) / ( A * x^2 + B )
  x = x * x;
  return x / ( x + 0.3f );
}

// Dither function
float4 Dither( float4 colour )
{
  // Use dither to reduce colour banding (vector should be random and value small, try different approaches)
  return float4( -0.05f *( colour.g + colour.b ), -0.05f *( colour.r + colour.b ), -0.05f *( colour.r + colour.g ), 1.0f );
}

//A.
float4 Glow1A_fp
	(
		float2 uv: TEXCOORD0,

		uniform sampler2D scene: register(s0),
		uniform float4 invTexSize
	) : COLOR
{
  // Use a constant pixel size to make the effect similar on every resolution
  // For Y blur use aspect ratio to make the same blur in horizontal and vertical directions
  const float pixelSizeModifier = invTexSize.x / invTexSize.y;

  // Pixel size precalculations
  const float pixelSize1 = PIXEL_SIZE_BASE   * pixelSizeModifier;
  const float pixelSize2 = PIXEL_SIZE_BASE_2 * pixelSizeModifier;
  const float pixelSize3 = PIXEL_SIZE_BASE_3 * pixelSizeModifier;
  const float pixelSize4 = PIXEL_SIZE_BASE_4 * pixelSizeModifier;
  const float pixelSize5 = PIXEL_SIZE_BASE_5 * pixelSizeModifier;

	// X-blur
	return
    tex2D( scene, float2( uv.x - pixelSize5, uv.y ) ) * C1 +
    tex2D( scene, float2( uv.x - pixelSize4, uv.y ) ) * C2 +
	  tex2D( scene, float2( uv.x - pixelSize3, uv.y ) ) * C3 +
	  tex2D( scene, float2( uv.x - pixelSize2, uv.y ) ) * C4 +
	  tex2D( scene, float2( uv.x - pixelSize1, uv.y ) ) * C5 +
	  tex2D( scene, float2( uv.x,              uv.y ) ) * C6 +
	  tex2D( scene, float2( uv.x + pixelSize1, uv.y ) ) * C5 +
	  tex2D( scene, float2( uv.x + pixelSize2, uv.y ) ) * C4 +
	  tex2D( scene, float2( uv.x + pixelSize3, uv.y ) ) * C3 +
    tex2D( scene, float2( uv.x + pixelSize4, uv.y ) ) * C2 +
	  tex2D( scene, float2( uv.x + pixelSize5, uv.y ) ) * C1;
}

//B.
float4 Glow1B_fp
	(
		float2 uv: TEXCOORD0,

		uniform sampler2D scene: register(s0),
		uniform sampler2D blurX: register(s1)
	) : COLOR
{
	// Y-blur
	const float4 colour =
    tex2D( blurX, float2( uv.x, uv.y - PIXEL_SIZE_BASE_5 ) ) * C1 +
	  tex2D( blurX, float2( uv.x, uv.y - PIXEL_SIZE_BASE_4 ) ) * C2 +
	  tex2D( blurX, float2( uv.x, uv.y - PIXEL_SIZE_BASE_3 ) ) * C3 +
	  tex2D( blurX, float2( uv.x, uv.y - PIXEL_SIZE_BASE_2 ) ) * C4 +
	  tex2D( blurX, float2( uv.x, uv.y - PIXEL_SIZE_BASE   ) ) * C5 +
	  tex2D( blurX, float2( uv.x, uv.y                     ) ) * C6 +
	  tex2D( blurX, float2( uv.x, uv.y + PIXEL_SIZE_BASE   ) ) * C5 +
	  tex2D( blurX, float2( uv.x, uv.y + PIXEL_SIZE_BASE_2 ) ) * C4 +
	  tex2D( blurX, float2( uv.x, uv.y + PIXEL_SIZE_BASE_3 ) ) * C3 +
	  tex2D( blurX, float2( uv.x, uv.y + PIXEL_SIZE_BASE_4 ) ) * C2 +
	  tex2D( blurX, float2( uv.x, uv.y + PIXEL_SIZE_BASE_5 ) ) * C1;


  // Add calculated glow to original colour and use filmic tone mapping and add dither
  return Dither( colour ) + Tonemap( 2.0f * tex2D( scene, uv ) + GLOW_MULTIPLIER * ( colour + 0.15 * colour * colour ) );
}